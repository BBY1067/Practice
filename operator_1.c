#define  _CRT_SECURE_NO_WARNINGS 1
#include<string.h>
#include<stdio.h>
//求一个整数储存在内存中的二进制中1的个数
//注：内存中储存的是整数的补码

//int main()
//{
//	int a = 0;
//	int count = 0;
//	scanf("%d", &a);
//	//while (a)
//	//{
//	//	if (a % 2 == 1)
//	//		count++;
//	//	a = a / 2;//比如10进制下的123，先除以10，商12，余3；再除以10，商1，余2；再除以10，余1.所以余数即为各数位上的数
//	//}
//	//上述方法存在缺点：正整数原码，补码，反码相同，而负数的不一样
//
//	//利用按位与特性解题
//	//00000000000000000000000000000011
//	//00000000000000000000000000000001
//	//00000000000000000000000000000001
//	int i = 0;
//	for (i = 0;i < 32;i++)
//	{
//		if (1 ==(( a >> i) & 1))
//			count++;
//	}
//	printf("二进制中1的个数为%d", count);
//	return 0;
//}


//按位取反~
//int main()
//{
//	int a = 11;//00000000000000000000000000001011
//	//将二进制中1011变为1111
//	//00000000000000000000000000001011
//	//用00000000000000000000000000000100按位或
//	a = a | (1 << 2);
//	printf("%d\n", a);
//	//还原a
//	//00000000000000000000000000001111
//	//11111111111111111111111111111011按位与
//	a = a & (~(1 << 2));//'~'按位取反
//	printf("%d\n", a);
//	return 0;
//}

//逻辑反操作！:(0为假，非0为真）
//int main()
//{
//	int a = 2;
//	printf("%d", !a);
//	return 0;
//}


//结构体操作符

struct movie
{
	char name[20];
	int year;
	char type[10];
};//不要忘记分号
int main()
{
	struct movie m1 = {"carol",2018,"lesbian"};
	struct movie* film = &m1;
	//访问方式：
	printf("%s\n", m1.name);
	printf("%s\n", (*film).name);
	printf("%s\n", film->name);
	return 0;
}