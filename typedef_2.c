#define  _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>

//位段：bit field
// 特征：
//1.位段的声明和结构体是类似的，但是位段的成员只能是int，unsigned int，signed int或者char类型（也属于整型家族类型）
//2.位段的成员名后面有一个冒号和一个数字

//struct a
//{
//	int a : 2;//a只需要占用2个bit位，但是位段开辟空间有自己的方式
//	int b : 3;
//	int c : 4;
//	unsigned int d : 4;
//};//a就是一个位段类型
//
//int main()
//{
//	struct a a1;
//	printf("%d\n", sizeof(a1));
//	return 0;
//}

//位段的内存分配
//位段的空间上是按照需要以4个字节（int）或者一个字节（char）来开辟的
//位段设计很多不确定因素，位段是不跨平台的， 涉及到可移植程序尽量不要使用位段
//
//根据需要的bit位开辟空间，要么开辟4个字节（32/64bit），要么开辟1个字节
//bit位不够开辟新的4个字节或1个字节存放成员内容
//所以位段后面的数字不能大于32

//开辟空间的时候从右到左使用bit位（与是否大小端无关，其实不确定）

//struct r
//{
//	char a : 2;
//	char b : 3;
//	char c : 5;
//	char d : 4;
//};
//
//int main()
//{
//	struct r r1 = { 0 };
//
//	r1.a = 10;
//	r1.b = 20;
//	r1.c = 5;
//	r1.d = 16;
//
//	return 0;
}//向位段成员赋值后，如果赋的值大于本身设定的比特位，则从右到左数，截断并从右到左存进位段本身设定好的bit位里面里面



//位段的跨平台问题：
//1.int位段被当成有符号数还是无符号数是不能确定的
//2.位段中最大位的数目不能确定（16位机器最大16，32最大32，写成27，在16位机器上会出问题）
//3.位段中的成员在内存中从左向右分配还是从右向左分配标准尚未定义
//4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是继续利用，这是不确定的

//总结：虽能节省空间，但是诸多不确定，慎用，有跨平台问题的存在

//位段应用于网络传输数据，节约空间